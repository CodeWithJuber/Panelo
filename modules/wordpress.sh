#!/bin/bash

# WordPress Installation Module
# Sets up Docker-based WordPress deployments

source "$(dirname "$0")/helper.sh" 2>/dev/null || true

# WordPress configuration
WORDPRESS_VERSION="latest"
WORDPRESS_APPS_DIR="/var/server-panel/apps/wordpress"
WORDPRESS_DATA_DIR="/var/server-panel/users"

install_wordpress_support() {
    log "INFO" "Setting up WordPress support"
    
    # Check if Docker is available
    if ! check_docker; then
        log "ERROR" "Docker is required for WordPress support"
        return 1
    fi
    
    # Create WordPress directories
    setup_wordpress_directories
    
    # Create WordPress templates
    create_wordpress_templates
    
    # Pull WordPress Docker image
    pull_wordpress_images
    
    # Create management scripts
    create_wordpress_scripts
    
    # Verify setup
    verify_wordpress_setup
    
    log "SUCCESS" "WordPress support installation completed"
}

setup_wordpress_directories() {
    log "INFO" "Setting up WordPress directories"
    
    # Create main WordPress apps directory
    create_directory "$WORDPRESS_APPS_DIR" "root" "root" "755"
    create_directory "$WORDPRESS_APPS_DIR/templates" "root" "root" "755"
    create_directory "$WORDPRESS_APPS_DIR/scripts" "root" "root" "755"
    
    log "SUCCESS" "WordPress directories created"
}

create_wordpress_templates() {
    log "INFO" "Creating WordPress templates"
    
    # Create Docker Compose template for WordPress
    cat > "$WORDPRESS_APPS_DIR/templates/docker-compose.yml" << 'EOF'
version: '3.8'

services:
  wordpress:
    image: wordpress:{{WORDPRESS_VERSION}}
    container_name: "{{APP_NAME}}-wordpress"
    restart: unless-stopped
    networks:
      - server-panel
    ports:
      - "127.0.0.1:{{APP_PORT}}:80"
    environment:
      WORDPRESS_DB_HOST: "{{DB_HOST}}"
      WORDPRESS_DB_USER: "{{DB_USER}}"
      WORDPRESS_DB_PASSWORD: "{{DB_PASSWORD}}"
      WORDPRESS_DB_NAME: "{{DB_NAME}}"
      WORDPRESS_TABLE_PREFIX: "{{DB_PREFIX}}"
      WORDPRESS_DEBUG: "{{DEBUG_MODE}}"
      WORDPRESS_CONFIG_EXTRA: |
        define('WP_MEMORY_LIMIT', '256M');
        define('WP_MAX_MEMORY_LIMIT', '512M');
        define('FORCE_SSL_ADMIN', true);
        define('AUTOMATIC_UPDATER_DISABLED', false);
        define('WP_AUTO_UPDATE_CORE', true);
    volumes:
      - "{{DATA_DIR}}/wordpress:/var/www/html"
      - "{{DATA_DIR}}/uploads:/var/www/html/wp-content/uploads"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.{{APP_NAME}}.rule=Host(`{{DOMAIN}}`)"
      - "traefik.http.routers.{{APP_NAME}}.tls=true"
      - "traefik.http.routers.{{APP_NAME}}.tls.certresolver=letsencrypt"

networks:
  server-panel:
    external: true
EOF
    
    # Create WordPress configuration template
    cat > "$WORDPRESS_APPS_DIR/templates/wp-config-custom.php" << 'EOF'
<?php
/**
 * Custom WordPress Configuration
 * Generated by Server Panel
 */

// Security keys and salts
{{WP_KEYS}}

// Additional WordPress settings
define('WP_DEBUG', {{DEBUG_MODE}});
define('WP_DEBUG_LOG', true);
define('WP_DEBUG_DISPLAY', false);

// Memory limits
define('WP_MEMORY_LIMIT', '256M');
define('WP_MAX_MEMORY_LIMIT', '512M');

// File permissions
define('FS_METHOD', 'direct');

// Automatic updates
define('AUTOMATIC_UPDATER_DISABLED', false);
define('WP_AUTO_UPDATE_CORE', true);

// Security enhancements
define('DISALLOW_FILE_EDIT', true);
define('FORCE_SSL_ADMIN', true);

// Upload settings
define('ALLOW_UNFILTERED_UPLOADS', false);

// Custom content directory (if needed)
// define('WP_CONTENT_DIR', dirname(__FILE__) . '/wp-content');
// define('WP_CONTENT_URL', 'https://{{DOMAIN}}/wp-content');

// That's all, stop editing! Happy publishing.
if (!defined('ABSPATH')) {
    define('ABSPATH', dirname(__FILE__) . '/');
}

require_once(ABSPATH . 'wp-settings.php');
EOF
    
    # Create NGINX configuration template for WordPress
    cat > "$WORDPRESS_APPS_DIR/templates/nginx-wordpress.conf" << 'EOF'
# WordPress NGINX Configuration for {{APP_NAME}}
upstream {{APP_NAME}}_backend {
    server 127.0.0.1:{{APP_PORT}};
    keepalive 32;
}

server {
    listen 80;
    listen [::]:80;
    server_name {{DOMAIN}};
    
    # Security
    location /.well-known/acme-challenge/ {
        root /var/www/html;
        allow all;
    }
    
    # Redirect to HTTPS
    location / {
        return 301 https://$server_name$request_uri;
    }
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name {{DOMAIN}};
    
    # SSL configuration
    ssl_certificate {{SSL_CERT}};
    ssl_certificate_key {{SSL_KEY}};
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    
    # WordPress specific security
    location ~ /\.ht {
        deny all;
    }
    
    location ~ /\.user\.ini {
        deny all;
    }
    
    location ~ ^/wp-content/uploads/.*\.php$ {
        deny all;
    }
    
    location ~ ^/wp-includes/.*\.php$ {
        deny all;
    }
    
    location ~ ^/wp-admin/includes/ {
        deny all;
    }
    
    # Protect wp-config.php
    location ~ /wp-config\.php {
        deny all;
    }
    
    # Block access to sensitive files
    location ~* /(?:uploads|files)/.*\.php$ {
        deny all;
    }
    
    # WordPress proxy
    location / {
        proxy_pass http://{{APP_NAME}}_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # WordPress specific headers
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Server $host;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Large file uploads
        client_max_body_size 100M;
        proxy_request_buffering off;
    }
    
    # Static file optimization
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        proxy_pass http://{{APP_NAME}}_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        expires 1y;
        add_header Cache-Control "public, immutable";
        access_log off;
    }
}
EOF
    
    # Create .htaccess template for WordPress
    cat > "$WORDPRESS_APPS_DIR/templates/.htaccess" << 'EOF'
# BEGIN WordPress Security
# Protect wp-config.php
<Files wp-config.php>
    Order allow,deny
    Deny from all
</Files>

# Protect .htaccess
<Files .htaccess>
    Order allow,deny
    Deny from all
</Files>

# Disable directory browsing
Options -Indexes

# Protect against script injection
<FilesMatch "\.(php|phtml|phps|php3|php4|php5|phtml)$">
    RewriteEngine On
    RewriteCond %{REQUEST_URI} !^/wp-admin/
    RewriteCond %{REQUEST_URI} !^/wp-includes/
    RewriteCond %{REQUEST_URI} !^/wp-content/themes/
    RewriteCond %{REQUEST_URI} ^/wp-content/uploads/
    RewriteRule ^(.*)$ - [F,L]
</FilesMatch>

# Limit file upload size
LimitRequestBody 104857600

# Hide WordPress version
<Files readme.html>
    Order allow,deny
    Deny from all
</Files>

<Files license.txt>
    Order allow,deny
    Deny from all
</Files>
# END WordPress Security

# BEGIN WordPress
<IfModule mod_rewrite.c>
RewriteEngine On
RewriteBase /
RewriteRule ^index\.php$ - [L]
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule . /index.php [L]
</IfModule>
# END WordPress
EOF
    
    log "SUCCESS" "WordPress templates created"
}

pull_wordpress_images() {
    log "INFO" "Pulling WordPress Docker images"
    
    # Pull latest WordPress image
    docker pull wordpress:latest
    docker pull wordpress:6.4
    docker pull wordpress:6.3
    
    # Pull additional useful images
    docker pull wordpress:cli
    docker pull phpmyadmin/phpmyadmin
    
    if [[ $? -eq 0 ]]; then
        log "SUCCESS" "WordPress Docker images pulled successfully"
    else
        log "ERROR" "Failed to pull WordPress Docker images"
        return 1
    fi
}

create_wordpress_scripts() {
    log "INFO" "Creating WordPress management scripts"
    
    # Create WordPress deployment script
    cat > "$WORDPRESS_APPS_DIR/scripts/deploy-wordpress.sh" << 'EOF'
#!/bin/bash

# WordPress Deployment Script
# Usage: ./deploy-wordpress.sh <app_name> <domain> <user_email>

source /opt/server-panel/modules/helper.sh

APP_NAME="$1"
DOMAIN="$2"
USER_EMAIL="$3"
WORDPRESS_VERSION="${4:-latest}"
DEBUG_MODE="${5:-false}"

if [[ -z "$APP_NAME" ]] || [[ -z "$DOMAIN" ]] || [[ -z "$USER_EMAIL" ]]; then
    log "ERROR" "Usage: $0 <app_name> <domain> <user_email> [wordpress_version] [debug_mode]"
    exit 1
fi

# Configuration
APP_DIR="/var/server-panel/apps/wordpress/$APP_NAME"
DATA_DIR="/var/server-panel/users/$USER_EMAIL/$APP_NAME"
APP_PORT=$(shuf -i 3100-3900 -n 1)

# Database configuration
DB_NAME="wp_${APP_NAME}"
DB_USER="wp_${APP_NAME}"
DB_PASSWORD=$(generate_password 16)
DB_PREFIX="wp_$(date +%s)_"
DB_HOST="127.0.0.1:3306"

deploy_wordpress() {
    log "INFO" "Deploying WordPress application: $APP_NAME"
    
    # Create application directories
    create_directory "$APP_DIR" "root" "root" "755"
    create_directory "$DATA_DIR" "www-data" "www-data" "755"
    create_directory "$DATA_DIR/wordpress" "www-data" "www-data" "755"
    create_directory "$DATA_DIR/uploads" "www-data" "www-data" "755"
    
    # Create database
    if ! /opt/server-panel/modules/mysql.sh create-db "$APP_NAME" "$DB_USER" "$DB_PASSWORD"; then
        log "ERROR" "Failed to create database for WordPress"
        return 1
    fi
    
    # Generate WordPress security keys
    local wp_keys
    wp_keys=$(curl -s https://api.wordpress.org/secret-key/1.1/salt/)
    
    # Create Docker Compose file from template
    sed -e "s/{{APP_NAME}}/$APP_NAME/g" \
        -e "s/{{DOMAIN}}/$DOMAIN/g" \
        -e "s/{{APP_PORT}}/$APP_PORT/g" \
        -e "s/{{WORDPRESS_VERSION}}/$WORDPRESS_VERSION/g" \
        -e "s/{{DB_HOST}}/$DB_HOST/g" \
        -e "s/{{DB_USER}}/$DB_USER/g" \
        -e "s/{{DB_PASSWORD}}/$DB_PASSWORD/g" \
        -e "s/{{DB_NAME}}/$DB_NAME/g" \
        -e "s/{{DB_PREFIX}}/$DB_PREFIX/g" \
        -e "s/{{DEBUG_MODE}}/$DEBUG_MODE/g" \
        -e "s|{{DATA_DIR}}|$DATA_DIR|g" \
        /var/server-panel/apps/wordpress/templates/docker-compose.yml > \
        "$APP_DIR/docker-compose.yml"
    
    # Create custom wp-config.php
    sed -e "s/{{DOMAIN}}/$DOMAIN/g" \
        -e "s/{{DEBUG_MODE}}/$DEBUG_MODE/g" \
        -e "s|{{WP_KEYS}}|$wp_keys|g" \
        /var/server-panel/apps/wordpress/templates/wp-config-custom.php > \
        "$DATA_DIR/wp-config-custom.php"
    
    # Copy .htaccess template
    cp /var/server-panel/apps/wordpress/templates/.htaccess "$DATA_DIR/wordpress/"
    
    # Start WordPress container
    cd "$APP_DIR"
    docker-compose up -d
    
    if [[ $? -eq 0 ]]; then
        # Wait for WordPress to be ready
        local max_attempts=30
        local attempt=1
        
        while [[ $attempt -le $max_attempts ]]; do
            if curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:$APP_PORT" | grep -q "200\|302"; then
                log "SUCCESS" "WordPress is ready on port $APP_PORT"
                break
            fi
            
            log "INFO" "Waiting for WordPress to start (attempt $attempt/$max_attempts)"
            sleep 3
            ((attempt++))
        done
        
        # Configure NGINX proxy
        /opt/server-panel/modules/nginx.sh add-proxy "$APP_NAME" "$DOMAIN" "$APP_PORT" "wordpress"
        
        # Create SSL certificate if needed
        if [[ ! -f "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" ]]; then
            log "INFO" "Creating SSL certificate for $DOMAIN"
            /opt/server-panel/modules/certbot.sh add-domain "$DOMAIN"
        fi
        
        # Save application configuration
        cat > "$APP_DIR/app.conf" << EOF
APP_NAME="$APP_NAME"
DOMAIN="$DOMAIN"
APP_PORT="$APP_PORT"
APP_TYPE="wordpress"
USER_EMAIL="$USER_EMAIL"
DB_NAME="$DB_NAME"
DB_USER="$DB_USER"
DB_HOST="$DB_HOST"
CREATED_AT="$(date)"
EOF
        
        log "SUCCESS" "WordPress deployed successfully"
        log "INFO" "Access your WordPress site at: https://$DOMAIN"
        log "INFO" "WordPress admin: https://$DOMAIN/wp-admin"
        log "INFO" "Database: $DB_NAME (user: $DB_USER)"
        
    else
        log "ERROR" "Failed to start WordPress container"
        return 1
    fi
}

# Execute the deployment when script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    deploy_wordpress
fi
EOF
    
    chmod +x "$WORDPRESS_APPS_DIR/scripts/deploy-wordpress.sh"
    
    # Create WordPress management script
    cat > "$WORDPRESS_APPS_DIR/scripts/manage-wordpress.sh" << 'EOF'
#!/bin/bash

# WordPress Management Script
# Usage: ./manage-wordpress.sh <action> <app_name> [options]

source /opt/server-panel/modules/helper.sh

ACTION="$1"
APP_NAME="$2"

if [[ -z "$ACTION" ]] || [[ -z "$APP_NAME" ]]; then
    echo "Usage: $0 <action> <app_name> [options]"
    echo "Actions: start, stop, restart, logs, backup, restore, update, delete"
    exit 1
fi

APP_DIR="/var/server-panel/apps/wordpress/$APP_NAME"

# Load app configuration
if [[ -f "$APP_DIR/app.conf" ]]; then
    source "$APP_DIR/app.conf"
else
    log "ERROR" "Application configuration not found: $APP_NAME"
    exit 1
fi

start_app() {
    log "INFO" "Starting WordPress application: $APP_NAME"
    cd "$APP_DIR"
    docker-compose up -d
}

stop_app() {
    log "INFO" "Stopping WordPress application: $APP_NAME"
    cd "$APP_DIR"
    docker-compose down
}

restart_app() {
    log "INFO" "Restarting WordPress application: $APP_NAME"
    stop_app
    sleep 2
    start_app
}

show_logs() {
    log "INFO" "Showing logs for WordPress application: $APP_NAME"
    cd "$APP_DIR"
    docker-compose logs -f
}

backup_app() {
    local backup_dir="/var/server-panel/backups/wordpress"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$backup_dir/${APP_NAME}_${timestamp}.tar.gz"
    
    log "INFO" "Creating backup for WordPress application: $APP_NAME"
    
    create_directory "$backup_dir" "root" "root" "755"
    
    # Backup database
    /opt/server-panel/modules/mysql.sh backup "$DB_NAME" "full"
    
    # Backup files
    tar -czf "$backup_file" -C "/var/server-panel/users/$USER_EMAIL" "$APP_NAME"
    
    if [[ $? -eq 0 ]]; then
        log "SUCCESS" "Backup created: $backup_file"
    else
        log "ERROR" "Backup failed"
        return 1
    fi
}

update_app() {
    log "INFO" "Updating WordPress application: $APP_NAME"
    
    # Backup before update
    backup_app
    
    # Pull latest WordPress image
    docker pull "wordpress:$WORDPRESS_VERSION"
    
    # Restart with new image
    restart_app
    
    log "SUCCESS" "WordPress update completed"
}

delete_app() {
    log "WARNING" "Deleting WordPress application: $APP_NAME"
    read -p "Are you sure you want to delete $APP_NAME? This cannot be undone. (y/N): " -r
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Stop and remove containers
        stop_app
        
        # Remove NGINX configuration
        /opt/server-panel/modules/nginx.sh remove-proxy "$APP_NAME"
        
        # Remove database
        /opt/server-panel/modules/mysql.sh remove-db "$APP_NAME" "$DB_USER"
        
        # Remove application files
        rm -rf "$APP_DIR"
        rm -rf "/var/server-panel/users/$USER_EMAIL/$APP_NAME"
        
        log "SUCCESS" "WordPress application deleted: $APP_NAME"
    else
        log "INFO" "Deletion cancelled"
    fi
}

case "$ACTION" in
    "start")
        start_app
        ;;
    "stop")
        stop_app
        ;;
    "restart")
        restart_app
        ;;
    "logs")
        show_logs
        ;;
    "backup")
        backup_app
        ;;
    "update")
        update_app
        ;;
    "delete")
        delete_app
        ;;
    *)
        echo "Unknown action: $ACTION"
        echo "Available actions: start, stop, restart, logs, backup, update, delete"
        exit 1
        ;;
esac
EOF
    
    chmod +x "$WORDPRESS_APPS_DIR/scripts/manage-wordpress.sh"
    
    log "SUCCESS" "WordPress management scripts created"
}

verify_wordpress_setup() {
    log "INFO" "Verifying WordPress setup"
    
    # Check if Docker images are available
    if docker images | grep -q "wordpress"; then
        log "SUCCESS" "WordPress Docker images are available"
    else
        log "ERROR" "WordPress Docker images not found"
        return 1
    fi
    
    # Check if templates exist
    if [[ -f "$WORDPRESS_APPS_DIR/templates/docker-compose.yml" ]]; then
        log "SUCCESS" "WordPress templates are available"
    else
        log "ERROR" "WordPress templates not found"
        return 1
    fi
    
    # Check if scripts are executable
    if [[ -x "$WORDPRESS_APPS_DIR/scripts/deploy-wordpress.sh" ]]; then
        log "SUCCESS" "WordPress deployment script is ready"
    else
        log "ERROR" "WordPress deployment script not found or not executable"
        return 1
    fi
    
    log "SUCCESS" "WordPress setup verification completed"
}

# Main execution
main() {
    case "${1:-install}" in
        "install")
            install_wordpress_support
            ;;
        "deploy")
            "$WORDPRESS_APPS_DIR/scripts/deploy-wordpress.sh" "$2" "$3" "$4" "$5" "$6"
            ;;
        "manage")
            "$WORDPRESS_APPS_DIR/scripts/manage-wordpress.sh" "$2" "$3" "$4"
            ;;
        *)
            echo "Usage: $0 [install|deploy|manage]"
            exit 1
            ;;
    esac
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi 